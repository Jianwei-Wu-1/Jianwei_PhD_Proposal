\section{Introduction}
\label{sec:introduction}

Unit tests are an important artifact that supports the software development process in several ways.
%
In addition to helping developers ensure the quality of their software by checking for failures~\cite{daka2014survey}, they can also serve as an important source of documentation not only for human developers but also for automated software engineering tools (e.g., recent work on fault localization by \citeauthor{li2019deepfl} uses test name information~\cite{li2019deepfl}).
%
For example, when a test fails, its name can provide the first step towards understanding the purpose of the test and ultimately fixing the cause of the observed failure.
%
Similarly, a test's name can help developers decide whether a test should be left alone, modified, or removed in response to changes in the application under test and whether the test should be included in a regression test suite.


In this proposal, we believe that test names are \enquote{good} if they are descriptive (e.g, they accurately summarize both the scenario and the expected outcome of the test~\cite{trenk14}) and \enquote{bad} if they are not descriptive.
%
This is because descriptive names:
\begin{enumerate*}
\item make it easier to tell if some functionality is not being tested---if a behavior is not mentioned in the name of a test, then the behavior is not being tested
\item help prevent tests that are too large or contain unrelated assertions---if a test cannot be summarized, it likely should be split into multiple tests
\item serve as documentation for the class under test---a class's supported functionality can be identified by reading the names of its tests
\end{enumerate*}~\cite{zhang2015automatically}.


Unfortunately, unit tests often lack descriptive names.
%
For example, an exploratory study by \citeauthor{zhang2015automatically} found that only \SI{9}{\percent} of the \num{213423} test names they considered were complete (i.e., fully described the body of test) while \SI{62}{\percent} were missing some information and \SI{29}{\percent} contained no useful information (e.g., tests named \enquote{test})~\cite{zhang2015automatically}.
%
Poor test names can be due to developers writing non-descriptive or incomplete names.
%
They can also occur due to incomplete code modifications.
%
For example, a developer may modify a test's body but fail to make the corresponding changes to the test's name.
%
Regardless of the cause, non-descriptive test names complicate comprehension tasks and increase the costs and difficulty of software development.


Because non-descriptive names negatively impact software development, there have been several attempts to address this issue.
%
One approach has been to automatically generate names based on implementations (e.g.,~\cite{arcuri2014automated, zhang2015automatically, daka2017generating}).
%
For example, \citeauthor{zhang2015automatically} and \citeauthor{daka2017generating} use static and dynamic analysis, respectively, to extract important expressions from a test's body and natural language processing techniques to transform such expression into test names \cite{zhang2015automatically, daka2017generating}. 
%
Another approach is to help developers improve their existing names by suggesting improvements.
%
For example, \citeauthor{host2009debugging} proposed an approach for Java methods and variables which uses a set of naming rules and related semantics~\cite{host2009debugging}, \citeauthor{li2019deepfl} provided a learning-based approach to locate software faults using test name information \cite{li2019deepfl}, and \citeauthor{allamanis2015suggesting} and \citeauthor{pradel2018deepbugs} use a model-based and a learning-based approach, respectively, to directly suggest better names or find name-based bugs to facilitate improvements~\cite{allamanis2015suggesting, pradel2018deepbugs}.


The first step of my dissertation work is to identify non-descriptive test names, so I developed a new, pattern-based approach that can:
\begin{enumerate*}
\item detect non-descriptive test names by finding information mismatches between the test name and body of a given JUnit test and provide descriptive information that is a summarization of the action, predicate, and scenario of the test body
\item use the descriptive information to facilitate the improvement of non-descriptive test names
\end{enumerate*}~\cite{wu2020pattern}.
%
Because it is necessary to understand when and how to apply descriptive test names to existing tests, we decided to build the pattern-based approach.
%
Unlike existing approaches which were designed to handle general methods, our approach is specific to JUnit tests.
%
The narrower scope of allows the approach to take advantage of the highly repetitive structures that exist in both test names and bodies of JUnit tests (see~\cref{sec:test-pattern-section}).
%
From a high-level point of view, the pattern-based approach uses a set of predefined patterns to extract descriptive information from both a test's name and body.
%
This information is then compared to find non-descriptive names (i.e., cases where the name does not accurately summarize the body).
%
When a mismatch is found, the information used by the approach can help developers address the mismatch and improve the quality of the tests by constructing descriptive names that can summarize the descriptive information from the test body.


Since when and how to apply descriptive test names to existing tests are sorted out, the next step is to build an automated approach that can generate descriptive names with the extracted information.
%
Many existing approaches try to generate descriptive test names by a series of pre-defined rules or models~\cite{arcuri2014automated, zhang2015automatically, allamanis2015suggesting, daka2017generating, li2019deepfl}, and their techniques performed well when solving their proposed problems.
%
However, while automatically generating descriptive names from test bodies eliminates the possibility of mismatches between names and bodies, those generated names do not always meet with developer approval (e.g., they may not fit with existing naming conventions).
%
This observation can also be applied to other approaches: using machine learning-based models can accurately summarize the important information of the test, but their summarized information is not always the same as what developer needs, or might even produce duplicate test names.


Recent machine learning-based approaches can be configured to generate descriptive test names~\cite{alon2018code2seq,alon2019code2vec}.
%
We chose a set of randomly selected projects from Github that are used as the input for those machine learning-based approaches to generate test names for all the unit tests in their test suites and compared all the generated test names with each other.
%
Nonetheless, thousands of duplicated test names were generated by both approaches~\cref{sec:duplication-names}, which can be barely used to provide any descriptive information and distinguish each test from other tests in its test class.
% TODO[done, change for all]: They are not necessailty unique test names (except among tests in the same class) but are names based on what makes the test unique.
Moreover, some test generation approaches might be able to generate test names that are based on what makes them unique but are not designed to do so~\cite{arcuri2014automated,zhang2015automatically,allamanis2015suggesting,daka2017generating}, hence there is no guarantee that these approaches would generate unique names for every test in any randomly selected project.
% TODO[done, moved up]: This doesn't really fit here....  Can it be moved earlier?
So as to generate descriptive names for unit tests (i.e., a descriptive test name can summarize important parts of the test body that are unique in its test class), I propose a concept-based approach that can be used to provide descriptive names with the uniqueness of test.


Therefore, to address these limitations and understand how developers name their unit tests, I further investigated how to automatically generate descriptive test names that follow the most common naming rationale used by developers.
%
To demonstrate that developers often use different naming rationales to name their tests, an empirical study was conducted as the first step towards building the approach~\cite{emp-study}.
%
The results of this study demonstrate that while different naming rationales do exist, a majority of the time tests are named after what makes them unique.
% TODO[done]: Fill in 
For example, \enquote{nullStringValue} is a test from the moshi project, and it is completely named after the information from its test body (i.e., \enquote{value((String) null)}) that makes this test unique in its test class.
%
Moreover, considering all the tests that were inspected in this study, \SI{76}{\percent} of the tests are constructed after what makes them unique, and those tests were randomly selected from \num{11} different Java projects.
%
We also discovered that it is feasible to extract the unique parts from the test body by utilizing a set of selective codes (i.e., include top-level and secondary codes), which came from the selective coding process using basic Java code elements as shown in~\cite{emp-study}.


Consequently, for the first part of my planned future work, I propose a novel, concept-based approach that can:
%
\begin{enumerate*}
\item verify whether a test is named after what makes it unique or not and use a set of selective codes to extract the unique parts from a test body
\item utilize the uniqueness of tests from the tagged text of tests to provide a uniqueness-based naming rationale for developers
\item generate straightforward results using formal concept analysis (FCA)~\cite{ganter2012formal} to facilitate improvement of existing test names (i.e., provide descriptive names)
\end{enumerate*}~\cite{emp-study}.
%
The following steps to complete the concept-based approach will be building an implementation of the approach and performing an empirical evaluation of the implemented approach with quantitative analysis.
%
So for the rest of planned future work, I plan to use a set of top-level and secondary codes to build an IDE plugin implementation of the concept-based approach and conduct the empirical evaluation of the approach by using the implementation of it.
%
Our approach is not only specific to JUnit tests but also one of the pioneers to focus on providing a uniqueness-based naming rationale to help developers improve existing test names.
%
From a high-level point of view, the concept-based approach uses a set of selective codes for tagging unit tests, which can also extract unique information from the test.
%
And that unique information can be used to generate descriptive test names that are based on the uniqueness of the test bodies.
%
In the process of using the selective codes, the approach utilizes formal concept analysis (FCA) to mimic the formal abstractions of concepts of human thoughts, which would help us to generate descriptive names in the same mental model as a human developer.
%
FCA will take the tagged text produced by the selective codes as input for building the formal concepts to generate descriptive test names (i.e., test names that contains unique information).
%
The unique information can be used to either improve existing test names that are lack of the unique information or generate descriptive test names with unique information (i.e., summarize all the information from the tagged text to construct a specific name).


For the second part of the planned future work, I plan to integrate the pattern-based approach (i.e., can detect non-descriptive test names) and the concept-based approach (i.e., can generate test names by a uniqueness-based naming rationale) to build a fully automated framework for providing descriptive test names for existing Java projects.
%
An exploratory study is needed, and it contains a further evaluation of the concept-based approach and a comparison between the concept-based approach and the pattern-based approach.
%
The exploratory study will follow these steps:
\begin{enumerate*}
\item an independent evaluation of the pattern-based and concept-based approaches will be conducted with consulting some experienced developers
\item a different set of experimental subjects (i.e., different from those used in the evaluations of the pattern-based and concept-based approaches) will be selected to script the survey questions
\item the results from the survey will be collected and analyzed with a quantitative analysis
\item our goal is to find the differences and similarities (i.e., potential overlap between the two approaches) of the pattern-based approach and the concept-based approach for motivating a possible combination of the two approaches
\end{enumerate*}.
%
Depending on the results from this exploratory study, first, we could gain more insight on how developers name their tests with the independent evaluation of both approaches.
%
Second, if we would manage to find a method that can combine the pattern-based and the concept-based approaches, it is possible to further propose a framework to generate descriptive test names for existing JUnit tests without developer involvement.
